# Java核心基础

### Java环境搭建 + 基础语法

1. 安装JDK 17（https://www.oracle.com/java/）
2. 安装IDEA社区版（https://www.jetbrains.com/idea/download/）
3. 配置环境变量（JAVA_HOME、Path）
4. 创建第一个Java项目
5. Hello World程序编写

### 基本数据类型

byte，short，int，long，float，double，boolean，char

### 引用数据类型

String，对象，数组，接口，枚举

### 类型转换

1. 不能对boolean类型进行类型转换。

2. 不能把对象类型转换成不相关类的对象。

3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

4. 转换过程中可能导致溢出或损失精度
5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入

#### 强转

```java
int i = 128;
byte b = (byte) i;
```

### 变量类型

局部变量，实例变量，静态变量，参数变量

### 运算符

算数，逻辑，关系，位，赋值

### instanceof

如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。

```java
( Object reference variable ) instanceof  (class/interface type)
```

例如：

```java
String name = "James";
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
```

### 循环结构

for	while	do...while

### 条件语句

if-else  switch-case

### StringBuild和StringBuffer

1. **单线程用 StringBuilder** - 快！
2. **多线程用 StringBuffer** - 安全！
3. **简单拼接用 String** - 方便！

**黄金法则：**

```java
// 90% 的场景用这个：
StringBuilder sb = new StringBuilder(预估长度);
sb.append(...).append(...).toString();

// 需要线程安全时：
StringBuffer buffer = new StringBuffer(预估长度);
buffer.append(...).append(...).toString();
```

### 数组

```java
// 方式1：先声明后初始化
int[] arr1;          // 推荐
int arr2[];          // 不推荐（C语言风格）

// 方式2：声明时初始化
int[] arr3 = new int[5];        // 长度为5，默认值0
String[] arr4 = new String[3];  // 长度为3，默认值null

// 方式3：直接赋值
int[] arr5 = {1, 2, 3, 4, 5};           // 简写形式
int[] arr6 = new int[]{1, 2, 3, 4, 5};  // 完整形式
```

### 类和对象

```java
// Q: 类和对象的区别？
// A: 类是模板，对象是实例

// Q: 构造方法的作用？
// A: 1. 创建对象 2. 初始化对象属性 3. 可以重载

// Q: this关键字的用途？
// A: 1. 区分同名变量 2. 调用其他构造方法 3. 返回当前对象 4. 传递当前对象

// Q: 静态和非静态的区别？
// A: 静态属于类，非静态属于对象

// Q: 为什么要有getter/setter？
// A: 1. 封装数据 2. 控制访问 3. 添加验证逻辑 4. 兼容性
```

### 封装

封装的优点：

- 良好点的封装能够减少耦合
- 类内部的结构可以自由修改
- 可以对成员变量进行更精确的控制
- 隐藏信息，实现细节

### 修饰符

##### 访问修饰符：

- private：只能本类访问，**不能修饰类**
- default：同一个包能访问
- protected：对同一包的类和所有子类可见
- public：所有类可见

#### 非访问修饰符：

1. static
   - static关键字用来声明独立于对象的静态变量，无论一个类实例化多少个对象，他的静态变量只有一份。静态变量也叫类变量。局部变量不能被声明为static变量。
   - static关键字用来声明独立于对象的静态方法，静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算。

   2.final

- 父类中的final方法可以被子类继承，但不能被子类重写。
- final类不能被继承

  3.abstract

- 抽象类不能实例化，声明抽象类的唯一目的是为了将来对该类进行扩充
- 一个类不能同时被abstaract和final修饰，如果一个类包含抽象方法，那么该类一定要声明为抽象类

#### 抽象方法

抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。

抽象方法不能被声明成 final 和 static。

任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。

### synchronized 修饰符

synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

### 继承

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

### 继承的特性

- 子类拥有父类非 private 的属性、方法。
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

### 方法的重写规则

- 参数列表与被重写方法的参数列表必须完全相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个类，则不能重写该类的方法。

### 重载(Overload)

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

**重载规则:**

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

### 多态的优点

- 1. 消除类型之间的耦合关系
- 2. 可替换性
- 3. 可扩充性
- 4. 接口性
- 5. 灵活性
- 6. 简化性

### 多态存在的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象：**Parent p = new Child();**

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

### 抽象类和接口的区别

- 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
- 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
- 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
- 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

> **注**：JDK 1.8 以后，接口里可以有静态方法和方法体了。
>
> **注**：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。更多内容可参考 [Java 8 默认方法](https://www.runoob.com/java/java8-default-methods.html)。
>
> **注**：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 [Java 9 私有接口方法](https://www.runoob.com/java/java9-private-interface-methods.html)。

### 接口与类的区别：

- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。

### 接口特性

- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。
- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。